# This is a configuration for taking Palo Alto Syslog files and shoving 
# them into Logstash/ES

### INPUT ###
input {
        file {
                        path => ["/var/log/syslogs-kibana/network.log"]
                        sincedb_path => "/var/log/logstash/sincedb"
                        start_position => "beginning"
                        type => "traffic"
                        tags => ["netsyslog"]
        }
        file {
                        path => ["/var/log/syslogs-kibana/urllogs.log"]
                        sincedb_path => "/var/log/logstash/urlsincedb"
                        start_position => "beginning"
                        codec => plain {
                                charset => "ISO-8859-1"
                        }
                        type => "url"
        }
        file {
                        path => ["/var/log/syslogs-kibana/bluecoat.log"]
                        sincedb_path => "/var/log/logstash/bluecoatsincedb"
                        start_position => "beginning"
                        codec => plain {
                                charset => "ISO-8859-1"
                        }
                        type => "proxy"
        }
        file {
                        sincedb_path => "/var/log/logstash/pxsquidaccessdb"
                        start_position => "beginning"
                        path => "/var/log/syslogs-kibana/pxsquid_access.log"
                        type => "pxsquidaccess"
        }
        file {
                        sincedb_path => "/var/log/logstash/checkpointdb"
                        start_position => "beginning"
                        path => "/var/log/syslogs-kibana/checkpoint-traffic.log"
                        type => "checkpoint"
        }
        file {
                        sincedb_path => "/var/log/logstash/bluecoateventdb"
                        start_position => "beginning"
                        path => ["/var/log/syslogs-kibana/bluecoateventlog.log"]
                        type => "bceventlog"
        }
        file {
                        sincedb_path => "/var/log/logstash/pravaildb"
                        start_position => "beginning"
                        path => ["/var/log/syslogs-kibana/pravail.log"]
                        type => "pravail"
        }
        file {
                        sincedb_path => "/var/log/logstash/nginxdb"
                        start_position => "beginning"
                        path => ["/var/log/syslogs-kibana/nginx-access.log"]
                        type => "nginx-access"
        }
        file {
                        sincedb_path => "/var/log/logstash/netscreendb"
                        start_position => "beginning"
                        path => ["/var/log/syslogs-kibana/netscreen.log"]
                        type => "netscreen"
        }
        file {
                        sincedb_path => "/var/log/logstash/junosdb"
                        start_position => "beginning"
                        path => ["/var/log/syslogs-kibana/junos_traffic.log"]
                        type => "junos"
        }
}

### FILTER ###
filter {
  if [type] == "traffic" {
    grok {
      #strips timestamp and host off of the front of the syslog message leaving the raw message generated by the syslog client and saves it as "raw_message"
      #patterns_dir => "/opt/logstash/patterns"
      match => [ "message", "%{TIMESTAMP_ISO8601:@timestamp} %{HOSTNAME:syslog_host} %{GREEDYDATA:raw_message}" ]
    }
    csv {
    source => "raw_message"

    columns => [ "PaloAltoDomain","ReceiveTime","SerialNum","Type","Subtype","ConfigVersion","GenerateTime","SourceAddress","DestinationAddress","NATSourceIP","NATDestinationIP","Rule","SourceUser","DestinationUser","Application","VirtualSystem","SourceZone","DestinationZone","InboundInterface","OutboundInterface","LogAction","TimeLogged","SessionID","RepeatCount","SourcePort","DestinationPort","NATSourcePort","NATDestinationPort","Flags","IPProtocol","Action","Bytes","BytesSent","BytesReceived","Packets","StartTime","ElapsedTimeInSec","Category","Padding","seqno","actionflags","SourceCountry","DestinationCountry","cpadding","pkts_sent","pkts_received","session_end_reason","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","action_source"]
    }
    date {
      timezone => "Europe/Madrid"
      match => [ "GenerateTime", "YYYY/MM/dd HH:mm:ss" ]
      target => "GenerateTime"
    }
    #convert fields to proper format
    mutate {
      convert => [ "Bytes", "integer" ]
      convert => [ "BytesReceived", "integer" ]
      convert => [ "BytesSent", "integer" ]
      convert => [ "ElapsedTimeInSec", "integer" ]
      convert => [ "geoip.area_code", "integer" ]
      convert => [ "geoip.dma_code", "integer" ]
      convert => [ "geoip.latitude", "float" ]
      convert => [ "geoip.longitude", "float" ]
      convert => [ "NATDestinationPort", "integer" ]
      convert => [ "NATSourcePort", "integer" ]
      convert => [ "Packets", "integer" ]
      convert => [ "pkts_received", "integer" ]
      convert => [ "pkts_sent", "integer" ]
      convert => [ "seqno", "integer" ]
      gsub => [ "Rule", " ", "_",
                "Application", "( |-)", "_" ]
      remove_field => [ "message", "raw_message" ]
    }

  #Geolocate logs that have SourceAddress and if that SourceAddress is a non-RFC1918 address
  if [SourceAddress] and [SourceAddress] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
      geoip {
           database => "/usr/share/logstash/GeoLite2-City.mmdb"
           source => "SourceAddress"
           target => "SourceGeo"
      }
      #Delete 0,0 in SourceGeo.location if equal to 0,0
      if ([SourceGeo.location] and [SourceGeo.location] =~ "0,0") {
        mutate {
          replace => [ "SourceGeo.location", "" ]
        }
      }
    }

  #Geolocate logs that have DestinationAddress and if that DestinationAddress is a non-RFC1918 address
  if [DestinationAddress] and [DestinationAddress] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
      geoip {
           database => "/usr/share/logstash/GeoLite2-City.mmdb"
           source => "DestinationAddress"
           target => "DestinationGeo"
      }
      #Delete 0,0 in DestinationGeo.location if equal to 0,0
      if ([DestinationGeo.location] and [DestinationGeo.location] =~ "0,0") {
        mutate {
          replace => [ "DestinationAddress.location", "" ]
        }
      }
    }

  #Takes the 5-tuple of source address, source port, destination address, destination port, and protocol and does a SHA1 hash to fingerprint the flow.  This is a useful
  #way to be able to do top N terms queries on flows, not just on one field.
  if [SourceAddress] and [DestinationAddress] {
    fingerprint {
      concatenate_sources => true
      method => "SHA1"
      key => "logstash"
      source => [ "SourceAddress", "SourcePort", "DestinationAddress", "DestinationPort", "IPProtocol" ]
    }
  }
  }
  if [type] == "url" {
    grok {
      #strips timestamp and host off of the front of the syslog message leaving the raw message generated by the syslog client and saves it as "raw_message"
      #patterns_dir => "/opt/logstash/patterns"
      match => { "message" => '%{TIMESTAMP_ISO8601} %{IPV4:firewallIP} %{HOSTNAME:firewall} %{IPV4:sourceIP} %{IPV4:destinationIP} %{NOTSPACE:application} %{NOTSPACE:category} %{NOTSPACE:action} %{USER:user} "%{URIHOST:URIHost}%{NOTSPACE:URIPath}" (%{NOTSPACE:user-agent})?'  }
        }

    date {
      timezone => "UTC"
      match => [ "GenerateTime", "YYYY/MM/dd HH:mm:ss" ]
    }
    if ![URIPath] {
     mutate {
        add_field => {"URIPath" => "/" }
     }
    }
    mutate {
        remove_field => ["message"]
    }
  }#endif
  if [type] == "proxy" {
                if ([message] =~ /^#/) {
                  drop{}
                }
    grok {
      #strips timestamp and host off of the front of the syslog message leaving the raw message generated by the syslog client and saves it as "raw_message"
      #patterns_dir => "/opt/logstash/patterns"
      #Log Kibana syslog-ng
      #match => [ "message", "%{TIMESTAMP_ISO8601:@timestamp} %{HOSTNAME:syslog_host} %{TIMESTAMP_ISO8601:realdate} %{GREEDYDATA:raw_message}" ]
      #Log commlogs
      match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:raw_message}" ]
    }
        csv {
        source => "raw_message"
	columns => ["time-taken", "c-ip", "sc-status", "s-action", "sc-bytes", "cs-bytes", "cs-method", "cs-uri-scheme", "cs-host", "cs-uri-stem", "csusername", "s-supplier-name", "rs(Content-Type)", "cs(User-Agent)", "sc-filter-result", "sc-filter-category","x-virus-id", "s-ip"]
        separator => " "
        }

                date {
                        match => ["timestamp", "YYYY-MM-dd HH:mm:ss" ]
                        timezone => "Europe/Madrid"
                  }

        if ([s-supplier-ip] and [s-supplier-ip] != "-") { 
               geoip {
                        source => "s-supplier-ip"
                  }
                }
                mutate {
                  convert => ["sc-bytes", "integer",
                                          "time-taken", "integer",
                                          "cs-bytes", "integer",
                                          "duration", "integer"
                                          ]
                }

                if [cs(User-Agent)] != "" {
                  useragent { source => "cs(User-Agent)" prefix => "user_agent." }
                }
                mutate {
                 remove_field => ["host", "date", "time", "gmttime", "localtime", "raw_message"]
                }
  }#endif
 
#### SQUID ####

  if [type] == "pxsquidaccess" {
                grok {
                        match => [ "message", "%{NUMBER:timestamp:float}\s+%{NUMBER:response_time:int} %{IPORHOST:src_ip} %{NOTSPACE:squid_request_status}/%{NUMBER:http_status_code:int} %{NUMBER:transfer_size:int} %{NOTSPACE:http_method} (%{URIPROTO:url_scheme}://)?(?<url_host>\S+?)(:%{INT:url_port})?(/%{NOTSPACE:url_path})?\s+%{NOTSPACE:client_identity}\s+%{NOTSPACE:peer_code}/%{NOTSPACE:peerhost}\s+%{NOTSPACE:content_type}" ]
                        #match => [ "message", "%{NUMBER:timestamp}\s+%{NUMBER:response_time} %{IPORHOST:src_ip} %{WORD:squid_request_status}/%{NUMBER:http_status_code} %{NUMBER:reply_size_include_header} %{WORD:http_method} %{URI:request_url} %{USERNAME:user} %{WORD:squid_hierarchy_status}/%{IPORHOST:server_ip_or_peer_name} (?\S+\/\S+)" ]
                        #match => [ "message", "%{NUMBER:timestamp}\s+%{NUMBER:response_time} %{IPORHOST:src_ip} %{WORD:squid_request_status}/%{NUMBER:http_status_code} %{NUMBER:reply_size_include_header} %{WORD:http_method} %{HOSTNAME:request_url}:%{NUMBER:tcp.port} %{NOTSPACE:user} %{WORD:squid}/%{GREEDYDATA:server_ip} %{NOTSPACE:content_type}" ]
                        #match => [ "message", "%{NUMBER:timestamp}\s+%{NUMBER:response_time} %{IPORHOST:src_ip} %{WORD:squid_request_status}/%{NUMBER:http_status_code} %{NUMBER:reply_size_include_header} %{WORD:http_method} %{URI:request_url} %{NOTSPACE:user} %{WORD:squid}/%{GREEDYDATA:server_ip} %{NOTSPACE:content_type}" ]
  }
                mutate {
                  convert => [ "response_time", "integer" ]
                  #remove_field => ["message"]
                }
 }

#### CHECKPOINT ####
if [type] == "checkpoint" {
    grok {
      match => [ "message", "%{TIMESTAMP_ISO8601}%{SPACE}%{HOSTNAME}%{SPACE}%{TIMESTAMP_ISO8601:realdate}%{SPACE}%{HOSTNAME:device}%{SPACE}%{NOTSPACE:name}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{GREEDYDATA:raw_message}" ]
    }
  kv {
	source => "raw_message"
	allow_duplicate_values => true
  }
    #date {
      #match => ["timestamp", "YYYY-MM-dd HH:mm:ss" ]
      #timezone => "Europe/Madrid"
    #}
                mutate {
                  remove_field => ["message","raw_message"]
                }
}
 
#### BCEVENT ####
  if [type] == "bceventlog" {
        grok {
             match => { "message" => '%{TIMESTAMP_ISO8601:@timestamp}%{SPACE}%{HOSTNAME:hostname}%{SPACE}%{NOTSPACE:product}:%{SPACE}%{NUMBER:code}%{SPACE}%{DATA:verdict}%{IPV4:clientIP}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE:user}%{SPACE}%{GREEDYDATA}' }
         }
  }

#### PRAVAIL DDoS ####
  if [type] == "pravail" {
        grok {
                #Blocked Host
                #match => [ "message", "%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{HOSTNAME:hostname}%{SPACE}%{NOTSPACE:product}:%{SPACE}%{CISCO_REASON:action}:%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:blocked_host}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{DATA:blocked_reason}%{SPACE}using%{SPACE}%{NOTSPACE:attack_port}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:destination}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}%{NUMBER:srcport}%{NOTSPACE}%{SPACE}%{NOTSPACE:url_pravail}"]
                match => [ "message", "%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{IPV4:device}%{SPACE}%{HOSTNAME:hostname}%{SPACE}%{NOTSPACE:product}:%{SPACE}%{DATA:action}:%{SPACE}%{DATA}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:blocked_host}%{SPACE}%{DATA}by%{SPACE}%{DATA:attack_type}using%{SPACE}%{DATA:dstport}%{SPACE}%{NOTSPACE}%{SPACE}destination%{SPACE}%{IPV4:destination}%{SPACE}%{DATA}port%{SPACE}%{NOTSPACE:srcport},%{NOTSPACE}%{SPACE}%{NOTSPACE:url_pravail}"]
        }
#        date {
#                timezone => "Europe/Madrid"
#                match => [ "timestamp","YYYY-MM-dd HH:mm:ss" ]
#                target => "realdate"
#        }
        mutate {
          convert => ["action", "string",
                                  "blocked_reason", "string",
                                  "product", "string",
                                  "url_pravail", "string"
                                  ]
           remove_field => ["message"]
        }
  }
  if [type] == "nginx-access" {
     grok {
       match => {
      "message" => '%{IPORHOST:remote_ip} - %{DATA:user_name} \[%{HTTPDATE:time}\] "%{WORD:request_action} %{DATA:request} HTTP/%{NUMBER:http_version}" %{NUMBER:response} %{NUMBER:bytes} "%{DATA:referrer}" "%{DATA:agent}"'
       }
     }
  date {
    match => [ "time", "dd/MMM/YYYY:HH:mm:ss Z" ]
    locale => en
  }

  geoip {
    source => "remote_ip"
    target => "geoip"
  }

  useragent {
    source => "agent"
    target => "user_agent"
  }
}

#### Firewall NetScreen ####
  if [type] == "netscreen" {
	grok {
		match => [ "message", "%{SYSLOGTIMESTAMP:date} %{IPORHOST:device} %{IPORHOST}: NetScreen device_id=%{WORD:device_id}%{DATA}: start_time=%{QUOTEDSTRING:start_time} duration=%{INT:duration} policy_id=%{INT:policy_id} service=%{DATA:service} proto=%{INT:proto} src zone=%{WORD:src_zone} dst zone=%{WORD:dst_zone} action=%{WORD:action} sent=%{INT:sent} rcvd=%{INT:rcvd} src=%{IPORHOST:src_ip} dst=%{IPORHOST:dst_ip} src_port=%{INT:src_port} dst_port=%{INT:dst_port} |src-xlated ip=%{IPORHOST:src_xlated_ip} |port=%{INT:src_xlated_port} |dst-xlated ip=%{IPORHOST:dst_xlated_ip} |port=%{INT:dst_xlated_port} session_id=%{INT:session_id} reason=%{GREEDYDATA:reason}" ]
	}
  }

#### Firewall Juniper SRX ####
  if [type] == "junos" {
    if [message] =~ "RT_FLOW_SESSION_CREATE" {
    	  mutate {
          add_tag => "FLOWCREATE"
        }
    }
    if [message] =~ "RT_FLOW_SESSION_DENY" {
        mutate {
          add_tag => "FLOWDENY"
        }
    }

  if "FLOWCREATE" in [tags] {
    grok {
    match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:device}.*session created %{IP:src_addr}/%{DATA:src_port}->%{IP:dst_addr}/%{DATA:dst_port} %{DATA:service} %{IP:nat_src_ip}/%{DATA:nat_src_port}->%{IP:nat_dst_ip}/%{DATA:nat_dst_port} %{DATA:src_nat_rule_name} %{DATA:dst_nat_rule_name} %{INT:protocol_id} %{DATA:policy_name} %{DATA:from_zone} %{DATA:to_zone} %{INT:session_id} .*" ]
    }
                date {
                        match => ["timestamp", "YYYY-MM-dd HH:mm:ss" ]
                        timezone => "Europe/Madrid"
                  }
  }

  if "FLOWDENY" in [tags] {
    grok {
    match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:device}.*session denied %{IP:src_addr}/%{DATA:src_port}->%{IP:dst_addr}/%{DATA:dst_port} %{DATA:service} %{INT:protocol_id}\(\d\) %{DATA:policy_name} %{DATA:from_zone} %{DATA:to_zone} .*" ]
    }
                date {
                        match => ["timestamp", "YYYY-MM-dd HH:mm:ss" ]
                        timezone => "Europe/Madrid"
                  }
  }
    translate {
      field => "device"
      destination => "device-name"
      dictionary => {
        "10.221.4.132" => "HEscorial"
        "10.221.11.253" => "HGregorio"
        "10.208.34.20" => "HSantaCristina"
        "10.208.34.28" => "HMostoles"
        "10.208.34.100" => "HSeveroOchoa"
        "10.208.34.108" => "Summa"
      }
    }
 }

} #end filter block

### OUTPUT ###
output {
  if [type] == "traffic" {
    elasticsearch {
    index => "pan-traffic-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/pan-traffic-template.json"
    }#endelasticsearch
  }#endif

  if [type] == "url" 
  {
    elasticsearch {
    index => "pan-url-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/pan-url-template.json"
    }#endelasticsearch
  }#endif
  if [type] == "proxy" 
  {
    elasticsearch {
    index => "bluecoat-logs-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/bluecoat-logs-template.json"
    }#endelasticsearch
  }#endif
  if [type] == "pxsquidaccess" 
  {
    elasticsearch {
    index => "pxsquid-logs-access-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    }#endelasticsearch
  }#endif
  if [type] == "checkpoint" 
  {
    elasticsearch {
    index => "checkpoint-logs"
    hosts => ["elasticsearch:9200"]
    }#endelasticsearch
  }#endif  
  if [type] == "bceventlog"
  {
    elasticsearch {
    index => "bcevent-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/bluecoat-syslog-template.json"
    }#endelasticsearch
  }
  if [type] == "pravail"
  {
    elasticsearch {
    index => "pravail-logs-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/pravail-logs-template.json"
    }#endelasticsearch
  }
  if [type] == "nginx-access"
  {
    elasticsearch {
    index => "nginx-access-logs-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    }#endelasticsearch
  }
  if [type] == "netscreen"
  {
    elasticsearch {
    index => "netscreen-logs-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    template => "/etc/logstash/templates/netscreen-traffic-template.json"
    }#endelasticsearch
  }
  if [type] == "junos"
  {
    elasticsearch {
    index => "junos-logs-%{+YYYY.MM.dd}"
    hosts => ["elasticsearch:9200"]
    }#endelasticsearch
  }
} #end output block
